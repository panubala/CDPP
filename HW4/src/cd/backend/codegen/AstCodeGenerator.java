package cd.backend.codegen;

import static cd.Config.MAIN;
import static cd.backend.codegen.RegisterManager.STACK_REG;

import java.io.Writer;
import java.util.HashMap;
import java.util.List;

import cd.Config;
import cd.Main;
import cd.backend.codegen.RegisterManager.Register;
import cd.ir.Ast.ClassDecl;
import cd.ir.Ast.MethodDecl;
import cd.ir.Ast.VarDecl;

public class AstCodeGenerator {

	protected RegsNeededVisitor rnv;
	
	protected ExprGenerator eg;
	protected StmtGenerator sg;
	
	public int currentStackPointerOffset;
	
	public static HashMap<String, VTable> classTables = new HashMap<String, VTable>();
	public static HashMap<String, VTable> objectTables = new HashMap<String, VTable>();
	
	protected final Main main;
	
	protected final AssemblyEmitter emit;
	protected final RegisterManager rm = new RegisterManager();
	
	protected static final String VAR_PREFIX = "var_";

	AstCodeGenerator(Main main, Writer out) {
		{
			initMethodData();
		}
		
		this.emit = new AssemblyEmitter(out);
		this.main = main;
		this.rnv = new RegsNeededVisitor();
		
		this.eg = new ExprGenerator(this);
		this.sg = new StmtGenerator(this);
	}

	protected void debug(String format, Object... args) {
		this.main.debug(format, args);
	}

	public static AstCodeGenerator createCodeGenerator(Main main, Writer out) {
		return new AstCodeGenerator(main, out);
	}
	
	
	/**
	 * Main method. Causes us to emit x86 assembly corresponding to {@code ast}
	 * into {@code file}. Throws a {@link RuntimeException} should any I/O error
	 * occur.
	 * 
	 * <p>
	 * The generated file will be divided into two sections:
	 * <ol>
	 * <li>Prologue: Generated by {@link #emitPrefix()}. This contains any
	 * introductory declarations and the like.
	 * <li>Body: Generated by {@link ExprGenerator}. This contains the main
	 * method definitions.
	 * </ol>
	 */
	public void go(List<? extends ClassDecl> astRoots) {
		
		// Emit some useful string constants:
		this.emit.emitRaw(Config.DATA_STR_SECTION);
		this.emit.emitLabel("STR_NL");
		this.emit.emitRaw(Config.DOT_STRING + " \"\\n\"");
		this.emit.emitLabel("STR_D");
		this.emit.emitRaw(Config.DOT_STRING + " \"%d\"");
		
		emitDataSection(astRoots);

		this.emit.emitRaw(Config.TEXT_SECTION);
		this.emit.emitRaw(".globl " + MAIN);
		this.emit.emitLabel(MAIN);
		
		this.emit.emit("enter", "$8", "$0");
		this.emit.emit("and", -16, STACK_REG); // What is the use of that?
		
		String calledClass = "Main";
		VTable vTable = AstCodeGenerator.classTables.get(calledClass);
		Register reg = this.rm.getRegister();
		// Load adress of CalledFnc
		this.emit.emit("leal", calledClass, reg);
		// Add Offset of method
		int offSet = vTable.getMethodOffset("main");

		this.emit.emit("addl", "$" + offSet, reg);
		this.emit.emit("movl", "0(" + reg + ")", reg);
		this.emit.emit("call", "*" + reg);
		this.rm.releaseRegister(reg);
		
		///////////////////////////////////////////////////
		
		for (ClassDecl ast : astRoots) {
			
			sg.gen(ast, new VarLocation(this));
		}
		
		printTables();
	}


	protected void initMethodData() {
		{
			rm.initRegisters();
		}
	}

	protected void emitDataSection(List<? extends ClassDecl> astRoots){
		
		this.emit.emitRaw(Config.DATA_INT_SECTION);
		
		for(ClassDecl ast: astRoots){
			emit.emitLabel(ast.name);
			VTable currT = new VTable(ast.name);
			classTables.put(ast.name, currT);
			
			int offSet = 0; //TODO implemetn better
			for(MethodDecl mths : ast.methods()){
				String label = Config.DOT_INT + " " + ast.name + "." + mths.name;
				currT.addMethod(mths.name, offSet);
				emit.emitRaw(label);
				offSet++;
			}
			
			//TODO field necessary?
			for(VarDecl field : ast.fields()){
				currT.addField(field.name, 0);
			}
			
		}
		
	}
	
	protected void emitMethodSuffix(boolean returnNull) {
		if (returnNull)
			emit.emit("movl", "$0", Register.EAX);
		emit.emitRaw("leave");
		emit.emitRaw("ret");
	}
	
	protected void call(){
		
		//save calle registers
		//push arguments
		//TODO, implemetn function for better overview
		
		
	}
	
	public void printTables(){
		System.out.println("////////////////////////////////");
		System.out.println("VirtualTables:");
		for(String vt : classTables.keySet()){
			System.out.println(vt);
			System.out.println(classTables.get(vt));
		}
		System.out.println("////////////////////////////////");
		System.out.println("ObjectTables:");
		for(String ot : objectTables.keySet()){
			System.out.println(ot);
			System.out.println(objectTables.get(ot));
		}
		System.out.println("////////////////////////////////");
		
		
	}
	
}