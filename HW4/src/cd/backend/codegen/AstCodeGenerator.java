package cd.backend.codegen;

import static cd.Config.MAIN;

import java.io.Writer;
import java.util.HashMap;
import java.util.List;

import cd.Config;
import cd.Main;
import cd.backend.codegen.RegisterManager.Register;
import cd.ir.Ast.ClassDecl;
import cd.ir.Ast.MethodDecl;
import cd.ir.Ast.VarDecl;

public class AstCodeGenerator {

	protected RegsNeededVisitor rnv;
	
	protected ExprGenerator eg;
	protected StmtGenerator sg;
	
	protected VarLocation vt;
	
	public int currentStackPointerOffset;
	
	public static HashMap<String, VTable> vTables = new HashMap();
	
	protected final Main main;
	
	protected final AssemblyEmitter emit;
	protected final RegisterManager rm = new RegisterManager();
	
	protected static final String VAR_PREFIX = "var_";

	AstCodeGenerator(Main main, Writer out) {
		{
			initMethodData();
		}
		
		this.emit = new AssemblyEmitter(out);
		this.main = main;
		this.rnv = new RegsNeededVisitor();
		
		this.vt = new VarLocation(this);
		
		this.eg = new ExprGenerator(this, vt);
		this.sg = new StmtGenerator(this, vt);
	}

	protected void debug(String format, Object... args) {
		this.main.debug(format, args);
	}

	public static AstCodeGenerator createCodeGenerator(Main main, Writer out) {
		return new AstCodeGenerator(main, out);
	}
	
	
	/**
	 * Main method. Causes us to emit x86 assembly corresponding to {@code ast}
	 * into {@code file}. Throws a {@link RuntimeException} should any I/O error
	 * occur.
	 * 
	 * <p>
	 * The generated file will be divided into two sections:
	 * <ol>
	 * <li>Prologue: Generated by {@link #emitPrefix()}. This contains any
	 * introductory declarations and the like.
	 * <li>Body: Generated by {@link ExprGenerator}. This contains the main
	 * method definitions.
	 * </ol>
	 */
	public void go(List<? extends ClassDecl> astRoots) {
		
		// Emit some useful string constants:
		this.emit.emitRaw(Config.DATA_STR_SECTION);
		this.emit.emitLabel("STR_NL");
		this.emit.emitRaw(Config.DOT_STRING + " \"\\n\"");
		this.emit.emitLabel("STR_D");
		this.emit.emitRaw(Config.DOT_STRING + " \"%d\"");
		
		emitDataSection(astRoots);
				

		this.emit.emitRaw(Config.TEXT_SECTION);
		this.emit.emitRaw(".globl " + MAIN);
		
		for (ClassDecl ast : astRoots) {
			sg.gen(ast);
		}
	}


	protected void initMethodData() {
		{
			rm.initRegisters();
		}
	}

	protected void emitDataSection(List<? extends ClassDecl> astRoots){
		
		this.emit.emitRaw(Config.DATA_INT_SECTION);
		
		for(ClassDecl ast: astRoots){
			emit.emitLabel(ast.name);
			VTable currT = new VTable(ast.name);
			vTables.put(ast.name, currT);
			
			int offSet = 0; //TODO implemetn better
			for(MethodDecl mths : ast.methods()){
				String label = Config.DOT_INT + " " + ast.name + "." + mths.name;
				currT.addMethod(mths.name, offSet);
				emit.emitRaw(label);
				offSet++;
			}
			
			//TODO field necessary?
			for(VarDecl field : ast.fields()){
				currT.addField(field.name, 0);
			}
			
		}
		
	}
	
	protected void emitMethodSuffix(boolean returnNull) {
		if (returnNull)
			emit.emit("movl", "$0", Register.EAX);
		emit.emitRaw("leave");
		emit.emitRaw("ret");
	}
}